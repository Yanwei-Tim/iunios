/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.aurora.launcher;

import android.R.integer;
import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.animation.ValueAnimator;
import android.animation.ValueAnimator.AnimatorUpdateListener;
import android.content.ComponentName;
import android.content.Context;
import android.content.pm.ResolveInfo;
import android.content.res.Resources;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.text.InputType;
import android.text.Selection;
import android.text.Spannable;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.ActionMode;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.Interpolator;
import android.view.animation.OvershootInterpolator;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.aurora.calender.CalenderPlugin;
import com.aurora.launcher.R;
import com.aurora.launcher.FolderInfo.FolderListener;
import com.aurora.launcher.Launcher.EditMode;
import com.aurora.plugin.DynIconDriver;
import com.aurora.plugin.DynIconPlg;

import java.util.ArrayList;
import java.util.List;

/**
 * 
 * @author hao jingjing
 * 
 */

/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class Folder extends LinearLayout implements DragSource, DropTarget, DragScroller, FolderListener, TextView.OnEditorActionListener,
        View.OnFocusChangeListener, View.OnLongClickListener, View.OnClickListener {
    private static final String TAG = "Launcher.Folder";
    private static final boolean Debug = true;
	public static final float ALPHA_EDITED_FOLDER = 0.4f;
    
    protected DragController mDragController;
    protected Launcher mLauncher;
    protected FolderInfo mInfo;

    static final int STATE_NONE = -1;
    static final int STATE_SMALL = 0;
    static final int STATE_ANIMATING = 1;
    static final int STATE_OPEN = 2;

    private int mExpandDuration;
    protected FolderWorkspace mContent;
    protected FolderPageIndicator mIndicator;
    private int mState = STATE_NONE;
    private static final int REORDER_ANIMATION_DURATION = 230;
    private static final int ON_EXIT_CLOSE_DELAY = 800;
    private FolderIcon mFolderIcon;
    private int mMaxCountX;
    private int mMaxCountY;
    private int mMaxNumItems;
    private Drawable mIconDrawable;
    private ShortcutInfo mCurrentDragInfo;
    private View mCurrentDragView;
    // 在onDrop时如果是mCurrentDragInfo就应该直接添加，无需再onAdd
    boolean mSuppressOnAdd = false;
    private int[] mTargetCell = new int[2];
    private int[] mPreviousTargetCell = new int[2];
    private Alarm mReorderAlarm = new Alarm();
    private Alarm mOnExitAlarm = new Alarm();
    
    private Rect mTempRect = new Rect();
    // 此变量表示是否正在拖动，一长按即设为true，当dropcomplete的时候设为false
    private boolean mDragInProgress = false;
    // 在drop完成后是否删除文件夹
    private boolean mDeleteFolderOnDropCompleted = false;
    // 暂停文件夹的删除
    private boolean mSuppressFolderDeletion = false;
    // 原本这个变量是没有作用的，后来在Dock栏中的图标要实行交换时这个就有用了，不应该删除folder
    private boolean mItemAddedBackToSelfViaIcon = false;
    FolderEditText mFolderName;
    private float mFolderIconPivotX;
    private float mFolderIconPivotY;

    private boolean mIsEditingName = false;
    private InputMethodManager mInputMethodManager;

    private static String sDefaultFolderName;
    //private static String sHintText;
    private ObjectAnimator mOpenCloseAnimator;

    private boolean mDestroyed;

    // Aurora <haojj> <2013-10-19> add for 自定义的一些变量 begin
    private boolean mInScrollArea = false;
    // 用于保存checked的数据
    ArrayList<BubbleTextView> mCheckedViews = new ArrayList<BubbleTextView>();
    // 保存空位emptypage, 2 to 3 begin
    private int[] mEmptyCell = new int[3];
    // 从folder外面进入folder时的一个变量
    boolean mOutDragOnAdd = false;
    // 在workspace中打开folder后并且在folder中拖动
    private boolean mOpenFolderAndDrag = false;
    // 记录page的变动 
    private int mTargetPage;
    private int mPreviousPage;
    private boolean mForceNoClose = false;
    private boolean mShowAddViewAfterUnload = false;
    private Drawable mNameBgDrawable = null;
    private int mFolderNameHeight;
    private int mFolderNameWidth;
    // 在EditText与Folder之间的距离
    private int mEditTextMargin; 
    // 保存新增的item
    private ArrayList<ShortcutInfo> mAddItemsInLastLayout = new ArrayList<ShortcutInfo>();
    private ArrayList<BubbleTextView> mAddViewsInLastLayout = new ArrayList<BubbleTextView>(); 
    private int mAddItemsScreen = -1;
    private int mDeleteDropTargerHeight =-1;
    private int mDisplayWidth=0;
    private int mDisplayHeight=0;
    private int mFolderContentTopInDragLayer = 0;
    
    private boolean showFolderAddViewOnAttach = false;
    protected void setShowFolderAddViewOnAttach(){
    	showFolderAddViewOnAttach = true;
    }
    
    private void clearAddItems(){
    	setAddItemsVisible(View.VISIBLE);
    	mAddItemsInLastLayout.clear();
    	mAddViewsInLastLayout.clear();
    	mAddItemsScreen = -1;
    }
    
    protected boolean isOpenAfterImport(){
    	return mAddItemsInLastLayout.size() > 0;
    }
    
    protected void initAddItemsInLastLayout(ArrayList<ShortcutInfo> items){
    	clearAddItems();
    	mAddItemsScreen = mContent.getChildCount() - 1;
    	TextView folderAddView = mContent.getFolderAddIcon();
    	if(folderAddView == null) return;
    	
		ItemInfo addInfo = (ItemInfo)folderAddView.getTag();
		if(addInfo.screen == mAddItemsScreen && addInfo.cellX == 0 && addInfo.cellY == 0){
			mAddItemsScreen = mAddItemsScreen - 1;
			if(mAddItemsScreen < 0) return;
		} 
		
    	CellLayout layout = (CellLayout) mContent.getChildAt(mAddItemsScreen);
    	if(layout != null){
	        for (int j = 0; j < layout.getCountY(); j++) {
	            for (int i = 0; i < layout.getCountX(); i++) {
	                View v = layout.getChildAt(i, j);
	                if( v == null) break;
	                if( v.getTag() instanceof ShortcutInfo){
	                	ShortcutInfo info = (ShortcutInfo) v.getTag();
	                	if(items.contains(info)){
	                		mAddItemsInLastLayout.add(info);
	                		mAddViewsInLastLayout.add((BubbleTextView)v);
	                	}
	                }
	            }
	        }
    	}
    }
    
    protected void setAddItemsVisible(int visible){
    	for(int i=0;i<mAddViewsInLastLayout.size();i++){
    		View iView = mAddViewsInLastLayout.get(i);
    		if(iView.getVisibility() != visible){
    			iView.setVisibility(visible);
    		}
    	}
    	View v = mContent.getFolderAddIcon();
    	if(v != null && v.getVisibility() != visible && !isImportMode()) {
    		v.setVisibility(visible);
    	}
    }
	// Aurora <haojj> <2013-9-24> end
    
    /**
     * Used to inflate the Workspace from XML.
     *
     * @param context The application's context.
     * @param attrs The attribtues set containing the Workspace's customization values.
     */
    public Folder(Context context, AttributeSet attrs) {
        super(context, attrs);
        setAlwaysDrawnWithCacheEnabled(false);

        Resources res = getResources();
        mMaxCountX = res.getInteger(R.integer.folder_max_count_x);
        mMaxCountY = res.getInteger(R.integer.folder_max_count_y);
        mMaxNumItems = res.getInteger(R.integer.folder_max_num_items);
        if (mMaxCountX < 0 || mMaxCountY < 0 || mMaxNumItems < 0) {
            mMaxCountX = LauncherModel.getCellCountX();
            mMaxCountY = LauncherModel.getCellCountY();
            mMaxNumItems = mMaxCountX * mMaxCountY;
        }

        mInputMethodManager = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);

        mExpandDuration = res.getInteger(R.integer.config_folderAnimDuration);

        /*if (sDefaultFolderName == null) {
            sDefaultFolderName = res.getString(R.string.folder_name);
        }*/
        setFolderDefaultName();
        
        // Aurora <haojj> <2013-10-14> add for ALPHA begin
        mNameBgDrawable = res.getDrawable(R.drawable.folder_name_edit_bg);
       /* mFolderNameWidth = mNameBgDrawable.getIntrinsicWidth();
        mFolderNameHeight = mNameBgDrawable.getIntrinsicHeight();*/
        mFolderNameWidth = res.getDimensionPixelOffset(R.dimen.folder_edittext_width);;
        mFolderNameHeight = res.getDimensionPixelOffset(R.dimen.folder_edittext_height);;
        mEditTextMargin = res.getDimensionPixelSize(R.dimen.folder_margin_buttom);
		// Aurora <haojj> <2013-10-14> end
        /*if (sHintText == null) {
            sHintText = res.getString(R.string.folder_hint_text);
        }*/
        mLauncher = (Launcher) context;
        mDeleteDropTargerHeight = res.getDimensionPixelOffset(R.dimen.qsb_bar_height);
        mFolderContentTopInDragLayer = res.getDimensionPixelOffset(R.dimen.folder_content_top_in_draglayer);
        mDisplayWidth = res.getDimensionPixelOffset(R.dimen.folder_display_width);
        mDisplayHeight =res.getDimensionPixelOffset(R.dimen.folder_display_height);
        Log.i("initfolder","mDisplayWidth = "+mDisplayWidth+"  height1="+mDisplayHeight);
        // We need this view to be focusable in touch mode so that when text editing of the folder
        // name is complete, we have something to focus on, thus hiding the cursor and giving
        // reliable behvior when clicking the text field (since it will always gain focus on click).
        setFocusableInTouchMode(true);
    }

    @Override
    protected void onAttachedToWindow() {
    	// TODO Auto-generated method stub
    	super.onAttachedToWindow();
    //add xiexiujie for to open the folder to display the first page 11.3 start
    	mContent.setCurrentPage(0);
    //add xiexiujie for to open the folder to display the first page 11.3 end	
    	mIndicator.setCurrentPosition(mContent.getCurrentPage());
    	if(isImportMode()) {
    		mContent.hideFolderAddView();
    		// setNameAndContentBg(true, false);
    		setNameAndContentBg(true);
    		mFolderName.setEnabled(false);
    	} else {
    		mContent.firstAttachFolderAddView();
    		showFolderAddViewInImportMode();
    		setNameAndContentBg(mOpenFolderAndDrag, false);
    	}
    	//mFolderName.setAlpha(0);
    }
    
    /*
     * 添加该方法的目的，选择一个文件夹A点击添加后，打开另外一个文件夹B，快速点击两次返回键，此时B中＋号丢失
     * 因为动作太快在onDetachedFromWindow的时候，isImportMode已经改变了，正常的步骤未执行
     */
    private void showFolderAddViewInImportMode(){
    	if(showFolderAddViewOnAttach) {
    		showFolderAddViewOnAttach = false;
			mContent.showFolderAddView();
			mFolderName.setEnabled(true);
    	}
    }
    
    @Override
    protected void onDetachedFromWindow() {
    	// TODO Auto-generated method stub
    	super.onDetachedFromWindow();
    	if(isImportMode()) {
    		// 当时出现了一个问题［如果文件夹某页只有一个+号，点击该+号进入到导入模式，此时按返回键会新增一页空的］，后来去掉这个就解决了
    		// 后修正updatepage的逻辑后，但是＋号不见了，因此需要添加再添加这个
    		// showFolderAddViewInImportMode();
    		showFolderAddViewOnAttach = true;
    	}
    	mOpenFolderAndDrag = false;
    }
    
    // Aurora <haojj> <2013-9-19> add for getting drag in progress begin
    public boolean getDragInProgress(){
    	return mDragInProgress;
    }
    // Aurora <haojj> <2013-9-19> end
    
    void setOpenFolderAndDrag(boolean openDrag){
    	mOpenFolderAndDrag = openDrag;
    }
    
    private boolean lastContentFlag = false;
    private void setNameAndContentBg(boolean contentFlag, boolean nameFlag){
    	setNameAndContentBg(contentFlag, nameFlag, false);
    }
    
    private void setNameAndContentBg(boolean contentFlag, boolean nameFlag, boolean animateBgToHide){
    	if(mContent.getBackground() == null) {
    		mContent.setBackgroundResource(R.drawable.folder_content_bg);
    	}
    	if(contentFlag != lastContentFlag){
	    	if(contentFlag){
	    		//mContent.setBackgroundResource(R.drawable.folder_content_bg);
	    		
	    		//mContent.getBackground().setAlpha(255); //长按，显示文件夹背景
	    		//iht 2015-01-06 长按Icon后，先隐藏[+]后显示背景
	    		postDelayed(new Runnable() {
					@Override
					public void run() {
						// TODO Auto-generated method stub
						mContent.getBackground().setAlpha(255); //长按，显示文件夹背景
					}
				}, 100);
	    	} else {
	    		//mContent.setBackground(null);
	    		if(animateBgToHide) {
	    			PropertyValuesHolder alphaHolder = PropertyValuesHolder.ofInt("alpha", 255, 0);
	    	    	ObjectAnimator oa =
	    	                LauncherAnimUtils.ofPropertyValuesHolder(mContent.getBackground(), alphaHolder);
	    	    	oa.setInterpolator(new DecelerateInterpolator());
	    	    	oa.setDuration(400);  //将背景消失
	    	    	oa.start();
	    		} else {
	    			mContent.getBackground().setAlpha(0);
	    		}
	    	}
    	}
    	
    	if(nameFlag){
    		//mFolderName.setBackgroundResource(R.drawable.folder_name_edit_bg);
    		mFolderName.setBackground(mNameBgDrawable);
    	} else {
    		mFolderName.setBackground(null);
    	}
    	lastContentFlag = contentFlag;
    }
    
    private void setNameAndContentBg(boolean contentFlag){
    	if(mContent.getBackground() == null) {
    		mContent.setBackgroundResource(R.drawable.folder_content_bg);
    	}
	    mContent.getBackground().setAlpha(0);
    	mFolderName.setBackground(null);
    	lastContentFlag = contentFlag;
    }
    
    void setContentBg(boolean show){
    	if(show){
    		mContent.getBackground().setAlpha(255);
    	} else {
    		mContent.getBackground().setAlpha(0);
		}
    }
    
    private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
            return false;
        }

        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
            return false;
        }

        public void onDestroyActionMode(ActionMode mode) {
        }

        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
            return false;
        }
    };

    public boolean isEditingName() {
        return mIsEditingName;
    }

    public void startEditingFolderName() {
    	// Aurora <haojj> <2013-9-16> add for changing backgroud begin
    	setNameAndContentBg(false, true);
    	// Aurora <haojj> <2013-9-16> end
        //mFolderName.setHint("");
        
        mIsEditingName = true;
    }

    public void dismissEditingName() {
        mInputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
        doneEditingFolderName(true);
    }

    public void doneEditingFolderName(boolean commit) {
    	// Aurora <haojj> <2013-9-16> add for changing backgroud begin
    	setFolderDefaultName();
    	mFolderName.setBackground(null);
		// Aurora <haojj> <2013-9-16> end
        //mFolderName.setHint(sHintText);
        // Convert to a string here to ensure that no other state associated with the text field
        // gets saved.
        String newTitle = mFolderName.getText().toString();
        if(TextUtils.isEmpty(newTitle)){
        	mInfo.setTitle(sDefaultFolderName);
        	mFolderName.setText(sDefaultFolderName);
        } else {
        	mInfo.setTitle(newTitle);
        }
        LauncherModel.updateItemInDatabase(mLauncher, mInfo);

        if (commit) {
            sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                    String.format(getContext().getString(R.string.folder_renamed), newTitle));
        }
        // In order to clear the focus from the text field, we set the focus on ourself. This
        // ensures that every time the field is clicked, focus is gained, giving reliable behavior.
        requestFocus();

        Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);
        mIsEditingName = false;
    }

    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            dismissEditingName();
            return true;
        }
        return false;
    }

    public View getEditTextRegion() {
        return mFolderName;
    }
    
    public int getIndicatorHeight() {
        return mIndicator.getDesiredHeight() + mEditTextMargin;
    }

    // Aurora <haojj> <2013-10-11> add for 虚拟一个空的DropTarget begin
    private DropTarget mEmptyDropTarget = null;
    public DropTarget getFolderEmptyDropTarget() {
    	if(mEmptyDropTarget == null){
    		mEmptyDropTarget = new FolderEmptyDropTarget(getContext());
    		((FolderEmptyDropTarget)mEmptyDropTarget).setLauncher(mLauncher);
    		((FolderEmptyDropTarget)mEmptyDropTarget).setFolder(this);
    	}
        return mEmptyDropTarget;
    }
    // Aurora <haojj> <2013-10-11> end
    
    public Drawable getDragDrawable() {
        return mIconDrawable;
    }

    /**
     * We need to handle touch events to prevent them from falling through to the workspace below.
     */
    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        return true;
    }

    public void setDragController(DragController dragController) {
        mDragController = dragController;
    }

    void setFolderIcon(FolderIcon icon) {
        mFolderIcon = icon;
    }
    
    // Aurora <haojj> <2013-10-11> add for field begin
    FolderIcon getFolderIcon(){
    	return mFolderIcon;
    }
    // Aurora <haojj> <2013-10-11> end

    @Override
    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
        // When the folder gets focus, we don't want to announce the list of items.
        return true;
    }

    /**
     * @return the FolderInfo object associated with this folder
     */
    FolderInfo getInfo() {
        return mInfo;
    }
    
    /**
     * we should use this method to change the value of mInfo member.
     * @param fi
     */
    public void setInfo(FolderInfo fi) {
    	mInfo = fi;
    	return;
    }

    /**
     * Creates a new UserFolder, inflated from R.layout.user_folder.
     *
     * @param context The application's context.
     *
     * @return A new UserFolder.
     */
    static Folder fromXml(Context context) {
        return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);
    }

    /**
     * This method is intended to make the UserFolder to be visually identical in size and position
     * to its associated FolderIcon. This allows for a seamless transition into the expanded state.
     */
    private void positionAndSizeAsIcon() {
        if (!(getParent() instanceof DragLayer)) return;
        setScaleX(0.8f); // source 0.8
        setScaleY(0.8f); // source 0.8
        setAlpha(0f);
        mState = STATE_SMALL;
    }

    public void setParamsAndCenter(){
        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        if (lp == null) {
            lp = new DragLayer.LayoutParams(0, 0);
            lp.customPosition = true;
            setLayoutParams(lp);
        }
        centerAboutIcon();
    }
    
    // Aurora <haojj> <2013-10-29> add for folder中动画的操作 begin
    public ValueAnimator animateShowEditName(long time, Interpolator ln){
    	ValueAnimator va = LauncherAnimUtils.ofFloat(0f, 1f);
    	va.removeAllUpdateListeners();
        va.addUpdateListener(new AnimatorUpdateListener(){
            public void onAnimationUpdate(ValueAnimator animation) {
                float progress = (Float) animation.getAnimatedValue();
                float translationY = 116 * (1 - progress);
                mFolderName.setAlpha(progress);
                mFolderName.setTranslationY(translationY);
            }
        });
        va.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
            	mFolderName.setAlpha(0);
            	mFolderName.setTranslationY(116f);
            }
            @Override
            public void onAnimationEnd(Animator animation) {
            }
        });
        va.setDuration(time);
        va.setInterpolator(ln);
        return va;
    }
    
    public Animator animateShowFolderAddIcon(long time, Interpolator ln){
    	final TextView folderAddIcon = mContent.getFolderAddIcon();
    	
    	ObjectAnimator oa = null;
    	if(folderAddIcon != null){
    	PropertyValuesHolder alphaHolder = PropertyValuesHolder.ofFloat("alpha", 0f, 1f);
        PropertyValuesHolder scaleXHolder = PropertyValuesHolder.ofFloat("scaleX", 0.8f, 1.0f);
        PropertyValuesHolder scaleYHolder = PropertyValuesHolder.ofFloat("scaleY", 0.8f, 1.0f);

        oa = LauncherAnimUtils.ofPropertyValuesHolder(folderAddIcon,alphaHolder, scaleXHolder, scaleYHolder);
        oa.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
            	folderAddIcon.setAlpha(0f);
            	mContent.setFolderAddIconScaleToSmall(0.8f);
            }
            @Override
            public void onAnimationEnd(Animator animation) {
            }
        });
        oa.setDuration(time);
		oa.setInterpolator(ln);
    	}
    	
    	/*ValueAnimator va = null;
    	if(folderAddIcon != null){
			va = LauncherAnimUtils.ofFloat(0.5f, 1.0f);
			va.removeAllUpdateListeners();
			va.addUpdateListener(new AnimatorUpdateListener() {
				public void onAnimationUpdate(ValueAnimator animation) {
					float progress = (Float) animation.getAnimatedValue();
					folderAddIcon.setAlpha(progress);
					folderAddIcon.setScaleX(progress);
					folderAddIcon.setScaleY(progress);
				}
			});
			va.setDuration(time);
			va.setInterpolator(ln);
    	} */
		return oa;
    }
    
    public ValueAnimator animateHideEditName(long time, Interpolator ln){
    	ValueAnimator va = LauncherAnimUtils.ofFloat(0.9f, 0f);
    	va.removeAllUpdateListeners();
        va.addUpdateListener(new AnimatorUpdateListener(){
            public void onAnimationUpdate(ValueAnimator animation) {
                float progress = (Float) animation.getAnimatedValue();
                float tranly = getResources().getDimension(R.dimen.tranly);
                float translationY = tranly * (1 - progress);
                mFolderName.setAlpha(progress);
                mFolderName.setTranslationY(translationY);
            }
        });
        /*va.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
            	mFolderName.setTranslationY(0f);
            }
            @Override
            public void onAnimationEnd(Animator animation) {
            }
        });*/
        va.setInterpolator(ln);
        va.setDuration(time);
        return va;
    }
    
    public Animator animateHideFolderAddIcon(long time, Interpolator ln){
    	final TextView mFolderAddIcon = mContent.getFolderAddIcon();
    	
    	ObjectAnimator oa = null;
    	if(mFolderAddIcon != null){
    	PropertyValuesHolder alphaHolder = PropertyValuesHolder.ofFloat("alpha", 1f, 0f);
        PropertyValuesHolder scaleXHolder = PropertyValuesHolder.ofFloat("scaleX", 1f, 0.8f);
        PropertyValuesHolder scaleYHolder = PropertyValuesHolder.ofFloat("scaleY", 1f, 0.8f);

        oa = LauncherAnimUtils.ofPropertyValuesHolder(mFolderAddIcon, alphaHolder, scaleXHolder, scaleYHolder);
        /*oa.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
            	mFolderAddIcon.setAlpha(0f);
            	mContent.setFolderAddIconScaleToZero();
            }
            @Override
            public void onAnimationEnd(Animator animation) {
            }
        });*/
        oa.setDuration(time);
		oa.setInterpolator(ln);
    	
    	
    	/*ValueAnimator va = null;
    	if(mFolderAddIcon != null){
			va = LauncherAnimUtils.ofFloat(1.0f, 0f);
			va.removeAllUpdateListeners();
			va.addUpdateListener(new AnimatorUpdateListener() {
				public void onAnimationUpdate(ValueAnimator animation) {
					float progress = (Float) animation.getAnimatedValue();
					mFolderAddIcon.setScaleX(progress);
					mFolderAddIcon.setScaleY(progress);
				}
			});
//			va.addListener(new AnimatorListenerAdapter() {
//				@Override
//				public void onAnimationStart(Animator animation) {
//					mFolderName.setAlpha(0);
//					mFolderName.setTranslationY(116f);
//				}
//
//				@Override
//				public void onAnimationEnd(Animator animation) {
//				}
//			});
			va.setDuration(time);
			va.setInterpolator(ln);*/
    	} 
		return oa;
    }
    // Aurora <haojj> <2013-10-29> end

    private int[] getPropertyTranslation(){
    	int[] translate = new int[2];
        DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
        float scale = parent.getDescendantRectRelativeToSelf(mFolderIcon, mTempRect);

        int centerX = (int) (mTempRect.left + mTempRect.width() * scale / 2);
        int centerY = (int) (mTempRect.top + mTempRect.height() * scale / 2) - 30;
        
        //float scale2 = parent.getDescendantRectRelativeToSelf(this, mTempRect);
        //int centerX2 = (int) (mTempRect.left + mTempRect.width() * scale2 / 2);
        //int centerY2 = (int) (mTempRect.top + mTempRect.height() * scale2 / 2);
        int centerX2 = (int) getResources().getDimension(R.dimen.startx); //R.ddimen.startx;
        int centerY2 = (int)getResources().getDimension(R.dimen.starty);
        
        translate[0] = centerX - centerX2;
        translate[1] = centerY - centerY2;
        
        // Log.e("HJJ", "NNNN>>scaled(" + originalScaleX + "," + originalScaleY + "), (" + centerX2 + "," + centerY2 + ")--->(" + centerX + "," + centerY + ")");
        // (centerX2-centerX) + "," + (centerY2-centerY));
        return translate;
    }
    //add by xiexiujie 10.28  for close folder animate start
	private int[] getPropertyTranslation2(){
    	int[] translate = new int[2];
        DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
        float scale = parent.getDescendantRectRelativeToSelf(mFolderIcon, mTempRect);
       
        int centerX = (int) (mTempRect.left + mTempRect.width() * scale / 2);
        int centerY = (int) (mTempRect.top + mTempRect.height() * scale / 2) ;
        if(mContent.getChildCountAtFristPage()+1<=4){
        	centerY= (int) (mTempRect.top + mTempRect.height() * scale / 2)+getResources().getInteger(R.integer.bg_offset1);        	
        }else if(mContent.getChildCountAtFristPage()+1<=8){
        	centerY= (int) (mTempRect.top + mTempRect.height() * scale / 2)+getResources().getInteger(R.integer.bg_offset2); 
        }else if(mContent.getChildCountAtFristPage()+1<=12){
        	centerY= (int) (mTempRect.top + mTempRect.height() * scale / 2)+getResources().getInteger(R.integer.bg_offset3); 
        }       
        int centerX2 = (int) getResources().getDimension(R.dimen.startx); 
        int centerY2 = (int)getResources().getDimension(R.dimen.starty);        
        translate[0] = centerX - centerX2;
        translate[1] = centerY - centerY2;                
        return translate;
    }
	  //add by xiexiujie 10.28  for close folder animate end
	private Animator animateFolderWorkspace(long time, Interpolator in, int translateX, int translateY, float origScaleX, float origScaleY){
    	PropertyValuesHolder alphaHolder = PropertyValuesHolder.ofFloat("alpha", 1);
    	PropertyValuesHolder translateXHolder = PropertyValuesHolder.ofFloat("translationX", translateX, 0); // 0.9f
        PropertyValuesHolder translateYHolder = PropertyValuesHolder.ofFloat("translationY", translateY, 0); // 0.9f
        
        PropertyValuesHolder scaleXHolder = PropertyValuesHolder.ofFloat("scaleX", origScaleX, 1.0f);
        PropertyValuesHolder scaleYHolder = PropertyValuesHolder.ofFloat("scaleY", origScaleY, 1.0f);

        ObjectAnimator oa =
                LauncherAnimUtils.ofPropertyValuesHolder(this, alphaHolder, scaleXHolder, scaleYHolder, translateXHolder, translateYHolder);

        setScaleX(origScaleX);
        setScaleY(origScaleY);
        setTranslationX(translateX);
        setTranslationY(translateY);
        
        oa.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
            }
            @Override
            public void onAnimationEnd(Animator animation) {
            	if(mAddItemsInLastLayout.size() > 0 && mAddItemsScreen >= 0 && mAddItemsScreen < mContent.getChildCount()){
            		int currentPage = mContent.getCurrentPage();
        			if(currentPage != mAddItemsScreen){
            			// mContent.snapToPage(mAddItemsScreen, 500);
            			int duration=Workspace.PAGE_SNAP_ANIMATION_DURATION+(mAddItemsScreen-currentPage)*120;
        				mContent.snapToPage(mAddItemsScreen,duration>1000?1000:duration);
	        			postDelayed(new Runnable() {
	    					@Override
	    					public void run() {
	    						// TODO Auto-generated method stub
	    						animateAddItems(300);
	    					}
	    				}, 500);
        			} else {
        				animateAddItems(300);
        			}
        		}
            }
        });
        oa.setDuration(time);
        oa.setInterpolator(in);
        return oa;
    }
    
    private Animator animateFolderBg(final ImageView bg, long time, Interpolator in, final int translateX, final int translateY, 
    		final float origScaleX, final float origScaleY){
        PropertyValuesHolder alphaHolder2 = PropertyValuesHolder.ofFloat("alpha",  0f);
        PropertyValuesHolder translateXHolder = PropertyValuesHolder.ofFloat("translationX", translateX, 0); // 0.9f
        PropertyValuesHolder translateYHolder = PropertyValuesHolder.ofFloat("translationY", translateY, 0); // 0.9f
        
        PropertyValuesHolder scaleXHolder = PropertyValuesHolder.ofFloat("scaleX", origScaleX, 1.0f);
        PropertyValuesHolder scaleYHolder = PropertyValuesHolder.ofFloat("scaleY", origScaleY, 1.0f);
        
        final ObjectAnimator ia =
                LauncherAnimUtils.ofPropertyValuesHolder(bg, alphaHolder2, scaleXHolder, scaleYHolder, translateXHolder, translateYHolder);
        ia.setDuration(time);
        ia.setInterpolator(in);
        ia.addListener(new AnimatorListenerAdapter() {
        	@Override
            public void onAnimationStart(Animator animation) {
        		//mFolderIcon.setVisibility(View.INVISIBLE);
        		//mFolderIcon.setAlpha(0f);
        		setScaleX(origScaleX);
                setScaleY(origScaleY);
                setTranslationX(translateX);
                setTranslationY(translateY);
        	}
        	@Override
            public void onAnimationEnd(Animator animation) {
        		mLauncher.getDragLayer().removeView(bg);
        	}
        });
        return ia;
    }
    
    private Animator singleItemAnimator(final View target, long duration, Interpolator ln){
    	ValueAnimator va = LauncherAnimUtils.ofFloat(0.5f, 1.0f);
		va.addUpdateListener(new AnimatorUpdateListener() {
			public void onAnimationUpdate(ValueAnimator animation) {
				float progress = (Float) animation.getAnimatedValue();
				target.setScaleX(progress);
				target.setScaleY(progress);
			}
		});
		va.addListener(new AnimatorListenerAdapter() {
			
			@Override
			public void onAnimationStart(Animator animation) {
				// TODO Auto-generated method stub
				target.setScaleX(0.5f);
				target.setScaleY(0.5f);
				target.setVisibility(View.VISIBLE);
			}
			
			@Override
			public void onAnimationEnd(Animator animation) {
				// TODO Auto-generated method stub
				
			}
		});
		va.setDuration(duration);
		va.setInterpolator(ln);
		return va;
    }
    
    private void animateAddItems(long duration){
    	Interpolator ln = new OvershootInterpolator();
    	ArrayList<Animator> items = new ArrayList<Animator>();
    	for(int i=0;i<mAddViewsInLastLayout.size();i++){
    		View target = mAddViewsInLastLayout.get(i);
    		items.add(singleItemAnimator(target, 200, ln));
    	}
    	final TextView folderAddIcon = mContent.getFolderAddIcon();
    	items.add(singleItemAnimator(folderAddIcon, duration, ln));
    	
    	AnimatorSet set = new AnimatorSet();
    	set.playTogether(items);
    	set.addListener(new AnimatorListenerAdapter() {
    		@Override
    		public void onAnimationStart(Animator animation) {
    			// TODO Auto-generated method stub
    			setLayerType(LAYER_TYPE_HARDWARE, null);
    			buildLayer();
    		}
    		@Override
    		public void onAnimationEnd(Animator animation) {
    			// TODO Auto-generated method stub
    			//setLayerType(LAYER_TYPE_NONE, null);
    			//ht 2014-10-13 to fix bug #8955 
    			post(new Runnable() {
					
					@Override
					public void run() {
						// TODO Auto-generated method stub
						setLayerType(LAYER_TYPE_NONE, null);
					}
				});
    			buildLayer();
    		}
		});
    	set.start();
    }
    
    public Animator animateOpen(long time, Interpolator in, ImageView bg) {
    	// Aurora <haojj> <2013-09-13> add for unchecked view begin
    	if(isImportMode()){
    		for(int i=0; i<mCheckedViews.size();i++){
    			mCheckedViews.get(i).setChecked(true);
    		}
    	}
    	// Aurora <haojj> <2013-09-13> add for unchecked view end
    	
        if (!(getParent() instanceof DragLayer)) return null;
        centerAboutIcon();
        final float orignal = getResources().getDimension(R.dimen.orignal);
        final float origScaleX = orignal / mContent.getDesiredWidth();
        final float origScaleY = orignal / mContent.getDesiredHeight();
        
        int[] translateProperty = getPropertyTranslation();
        final int translateX = translateProperty[0];
        final int translateY = translateProperty[1];
        //add by xiexiujie 10.28  for close folder animate start
        int[] translateProperty2 = getPropertyTranslation2();
        final int translateX2 = translateProperty2[0];
        final int translateY2 = translateProperty2[1];
        //add by xiexiujie 10.28  for close folder animate end
        
        Animator oa = animateFolderWorkspace(time, in, translateX2, translateY2, origScaleX, origScaleY);
        if(bg == null) {
        	return oa;
        }
        	
        /*Animator ia = animateFolderBg(bg, time, in, translateX, translateY, origScaleX, origScaleY);
        AnimatorSet set = new AnimatorSet();
        set.playTogether(oa, ia);*/
        
        //setLayerType(LAYER_TYPE_HARDWARE, null);
        //buildLayer();
        return oa;
    }

    private void sendCustomAccessibilityEvent(int type, String text) {
        AccessibilityManager accessibilityManager = (AccessibilityManager)
                getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
        if (accessibilityManager.isEnabled()) {
            AccessibilityEvent event = AccessibilityEvent.obtain(type);
            onInitializeAccessibilityEvent(event);
            event.getText().add(text);
            accessibilityManager.sendAccessibilityEvent(event);
        }
    }

    protected void setFocusOnFirstChild() {
        View firstChild = ((CellLayout)mContent.getChildAt(0)).getChildAt(0, 0);
        if (firstChild != null) {
            firstChild.requestFocus();
        }
    }

    public Animator animateClosed(long time, Interpolator ln) {
    	// Aurora <haojj> <2013-09-13> add for unchecked view begin
    	clearAddItems();
    	if(isImportMode()){
    		for(int i=0; i<mCheckedViews.size();i++){
    			mCheckedViews.get(i).setChecked(false);
    		}
    	}
    	// Aurora <haojj> <2013-09-13> add for unchecked view end
    	
        /*if (!(getParent() instanceof DragLayer)) return null;
        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 0);
        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 0.9f);
        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 0.9f);
        final ObjectAnimator oa = mOpenCloseAnimator =
                LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);*/
    	
    	final float scaled = 196f / 1032;
        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1f, 0);
        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1f, 0); // 0.9f
        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1f, 0); // 0.9f
        
        
        DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
        float scale = parent.getDescendantRectRelativeToSelf(mFolderIcon, mTempRect);

        int centerX = (int) (mTempRect.left + mTempRect.width() * scale / 2);
        int centerY = (int) (mTempRect.top + mTempRect.height() * scale / 2);
        if(mFolderIcon != null){
        	if(mFolderIcon.getParent() != null && mLauncher.isHotseatLayout((View)mFolderIcon.getParent().getParent())){
        		centerY += 75;
	        } else {
	        	if(mInfo.cellY == 0 || mInfo.cellY == 1){
		        	centerY -= 75;
		        } else if(mInfo.cellY == 3 || mInfo.cellY == 4) {
		        	centerY += 75;
		        }
		        
		        if(mInfo.cellX == 0) {
		        	centerX -= 60;
		        } else if(mInfo.cellX == 3) {
		        	centerX += 60;
		        }
	        }
        	//Log.e("HJJ", "Folder cellx:" + mInfo.cellX + ", cellY:" + mInfo.cellY);
        }
        //Log.e("HJJ", "NNNN>>Rect(" + mTempRect.left + "," + mTempRect.top + "),(" + mTempRect.width() + "," + mTempRect.height() + "),(" + scale + ")");
        
        float scale2 = parent.getDescendantRectRelativeToSelf(mContent, mTempRect);
        int centerX2 = (int) (mTempRect.left + mTempRect.width() * scale2 / 2);
        int centerY2 = (int) (mTempRect.top + mTempRect.height() * scale2 / 2);
        
        // (540, 768) --> ()
        //Log.e("HJJ", "NNNN>>scaled" + scaled + ", (" + centerX2 + "," + centerY2 + "--->(" + centerX + "," + centerY + ")");
        // (centerX2-centerX) + "," + (centerY2-centerY));
        PropertyValuesHolder translateX = PropertyValuesHolder.ofFloat("translationX", (centerX - centerX2)); // 0.9f
        PropertyValuesHolder translateY = PropertyValuesHolder.ofFloat("translationY", (centerY - centerY2)); // 0.9f
        
        final ObjectAnimator oa = mOpenCloseAnimator =
                LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY, translateX, translateY);
        
        //Log.e("HJJ", "pppppp>> X:" + mContent.getPivotX() + ", Y:" + mContent.getPivotY() + "," + mContent.getMeasuredWidth() + "," + mContent.getMeasuredHeight() + ","
        // + getTranslationX() + "," + getTranslationY() + "," + (centerX2-centerX) + "," + (centerY2-centerY));

        oa.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                onCloseComplete();
                setTranslationX(0f);
                setTranslationY(0f);
                if(mContent.getBackground() != null){
	                if(lastContentFlag) {
	                	mContent.getBackground().setAlpha(255);
	                } else {
	                	mContent.getBackground().setAlpha(0);
	                }
                }
    			//setLayerType(LAYER_TYPE_NONE, null);
    			//ht 2014-10-13 to fix bug #8955 
    			post(new Runnable() {
					
					@Override
					public void run() {
						// TODO Auto-generated method stub
						setLayerType(LAYER_TYPE_NONE, null);
					}
				});
                mState = STATE_SMALL;
            }
            @Override
            public void onAnimationStart(Animator animation) {
            	setLayerType(LAYER_TYPE_HARDWARE, null); //iht 2014-11-20
            	buildLayer();
            	
                sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                        getContext().getString(R.string.folder_closed));
                mState = STATE_ANIMATING;
                // 全透的话透明度太高，因此如此设计, 一个文件中的icon打开另一个文件中并放置会出现问题
                if(mContent.getBackground() != null) {
                	//mContent.getBackground().setAlpha(100);
                	mContent.getBackground().setAlpha(0);
                }
            }
        });
        // oa.setDuration(mExpandDuration);
        oa.setInterpolator(ln);
        oa.setDuration(time);
        //setLayerType(LAYER_TYPE_HARDWARE, null); //iht 2014-11-20
        //buildLayer();
        
//        post(new Runnable() {
//            public void run() {
//                // Check if the animator changed in the meantime
//                if (oa != mOpenCloseAnimator)
//                    return;
//                oa.start();
//            }
//        });
        return oa;
    }

    void notifyDataSetChanged() {
        // recreate all the children if the data set changes under us. We may want to do this more
        // intelligently (ie just removing the views that should no longer exist)
        mContent.removeAllViewsInLayout();
        bind(mInfo);
    }

    OnAlarmListener mReorderAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
        	// Log.e("HJJ", "[222]mTargetCell==>x:" + mTargetCell[0] + ",y:" + mTargetCell[1] + ";mEmptyCell==>x:" + mEmptyCell[0] + ",y:" + mEmptyCell[1]);
            realTimeReorder(mEmptyCell, mTargetCell, mTargetPage);
        }
    };

    boolean readingOrderGreaterThan(int[] v1, int[] v2) {
        if (v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0])) {
            return true;
        } else {
            return false;
        }
    }
    
    // 每次调用完了以后都会调用onDropComplete函数，其中会调用mContent.reArranageChildren，在这里把保存到数据库的数据写入
    private void realTimeReorder(int[] empty, int[] target, int targetPage) {
        boolean wrap;
        int startX;
        int endX;
        int startY;
        int endY;
        int delay = 30;
        float delayAmount = 0;
        int finalX = FolderWorkspace.DEFAULT_CELL_COUNT_X - 1;
    	int finalY = FolderWorkspace.DEFAULT_CELL_COUNT_Y - 1;
    	int emptyPage = empty[2];
        
        if(emptyPage == targetPage){
        	// original <===>
	        CellLayout currentLayout = (CellLayout)mContent.getChildAt(targetPage);
	        if (readingOrderGreaterThan(target, empty)) {
	            wrap = empty[0] >= currentLayout.getCountX() - 1;
	            startY = wrap ? empty[1] + 1 : empty[1];
	            for (int y = startY; y <= target[1]; y++) {
	                startX = y == empty[1] ? empty[0] + 1 : 0;
	                endX = y < target[1] ? currentLayout.getCountX() - 1 : target[0];
	                for (int x = startX; x <= endX; x++) {
	                    View v = currentLayout.getChildAt(x,y);
	                    if (currentLayout.animateChildToPosition(v, empty[0], empty[1],
	                            REORDER_ANIMATION_DURATION, delay, true, true)) {
	                        empty[0] = x;
	                        empty[1] = y;
	                        delay += delayAmount;
	                        delayAmount *= 0.1;
	                    }
	                }
	            }
	        } else {
	            wrap = empty[0] == 0;
	            startY = wrap ? empty[1] - 1 : empty[1];
	            for (int y = startY; y >= target[1]; y--) {
	                startX = y == empty[1] ? empty[0] - 1 : currentLayout.getCountX() - 1;
	                endX = y > target[1] ? 0 : target[0];
	                for (int x = startX; x >= endX; x--) {
	                    View v = currentLayout.getChildAt(x,y);
	                    if (currentLayout.animateChildToPosition(v, empty[0], empty[1],
	                            REORDER_ANIMATION_DURATION, delay, true, true)) {
	                        empty[0] = x;
	                        empty[1] = y;
	                        delay += delayAmount;
	                        delayAmount *= 0.9;
	                    }
	                }
	            }
	        }
        } else if(emptyPage < targetPage){
        	// scrollright ==>
        	for(int page = empty[2]; page <= targetPage; page++){
        		CellLayout currentLayout = (CellLayout) mContent.getChildAt(page);
        		wrap = empty[0] >= currentLayout.getCountX() - 1;
	            startY = wrap ? empty[1] + 1 : empty[1];
	            endY = page < targetPage ? currentLayout.getCountY() - 1 : target[1];
	            for (int y = startY; y <= endY; y++) {
	                startX = y == empty[1] ? empty[0] + 1 : 0;
	                endX = (page < targetPage) ? currentLayout.getCountX() - 1 : (y < target[1] ? currentLayout.getCountX() - 1 : target[0]);
	                for (int x = startX; x <= endX; x++) {
	                    View v = currentLayout.getChildAt(x,y);
	                    if (currentLayout.animateChildToPosition(v, empty[0], empty[1],
	                            REORDER_ANIMATION_DURATION, delay, true, true)) { 
	                        empty[0] = x;
	                        empty[1] = y;
	                        delay += delayAmount;
	                        delayAmount *= 0.9;
	                    }
	                }
	            }
	            int nextPage = page + 1;
	            if(nextPage <= targetPage){
	            	CellLayout nextLayout = (CellLayout) mContent.getChildAt(nextPage);
	            	View firstView = nextLayout.getChildAt(0, 0);
	            	if(null == firstView) continue;
	            	final float translateX = ((BubbleTextView)firstView).getMeasuredWidth();
	            	
	            	nextLayout.removeView(firstView);
	            	
	            	CellLayout.LayoutParams lp = new CellLayout.LayoutParams(finalX,
	            			finalY, 1, 1);
	            	ItemInfo item = (ItemInfo)firstView.getTag();
	            	firstView.setVisibility(View.INVISIBLE);
	        		if(currentLayout.addViewToCellLayout(firstView, -1, (int) item.id,
	        				lp, true)){
	        			empty[0] = 0;
                        empty[1] = 0;
                        empty[2] = nextPage;
                        animateFirstViewToPosition(firstView, translateX, REORDER_ANIMATION_DURATION, delay);
                        delay += delayAmount;
                        delayAmount *= 0.9;
	        		} else {
	        			firstView.setVisibility(View.VISIBLE);
	        		}
	            }
        	}
        } else if(emptyPage > targetPage){
        	// scroolleft  <==
        	for(int page = emptyPage; page >= targetPage; page--){
        		CellLayout currentLayout = (CellLayout) mContent.getChildAt(page);
	        	wrap = empty[0] == 0;
	            startY = (page == emptyPage) ? (wrap ? empty[1] - 1 : empty[1]) : finalY;
	            endY = page > targetPage ? 0 : target[1];
	            for (int y = startY; y >= endY; y--) {
	                startX = (page == emptyPage) ? (y == empty[1] ? empty[0] - 1 : finalX) : finalX;
	                endX = page > targetPage ? 0 : (y > target[1] ? 0 : target[0]);
	                for (int x = startX; x >= endX; x--) {
	                    View v = currentLayout.getChildAt(x,y);
	                    if (currentLayout.animateChildToPosition(v, empty[0], empty[1],
	                            REORDER_ANIMATION_DURATION, delay, true, true)) {
	                        empty[0] = x;
	                        empty[1] = y;
	                        delay += delayAmount;
	                        delayAmount *= 0.9;
	                    }
	                }
	            }
	            int prevPage = page - 1;
	            if(prevPage >= targetPage){
	            	CellLayout prevLayout = (CellLayout) mContent.getChildAt(prevPage);
	            	View lastView = prevLayout.getChildAt(finalX, finalY);
	            	if(null == lastView) continue;
	            	prevLayout.removeView(lastView);
	            	
	            	CellLayout.LayoutParams lp = new CellLayout.LayoutParams(0,
	            			0, 1, 1);
	            	ItemInfo item = (ItemInfo)lastView.getTag();
	        		if(currentLayout.addViewToCellLayout(lastView, -1, (int) item.id,
	        				lp, true)){
	        			empty[0] = finalX;
                        empty[1] = finalY;
                        empty[2] = prevPage;
	        		}
	            }
        	}
        }
    }
    // Aurora <haojj> <2013-11-2> add for 保留作为以后补充 begin
    private void animateFirstViewToGone(final View child, final float translateX, long duration, long delay){
    	//Toast.makeText(mLauncher, "gone translateX:" + translateX, Toast.LENGTH_SHORT).show();
    	PropertyValuesHolder translateXHolder = PropertyValuesHolder.ofFloat("translationX", 0, -translateX);

    	ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(child, translateXHolder);
		oa.setDuration(duration);
		oa.setStartDelay(delay);
		oa.addListener(new AnimatorListenerAdapter() {
			public void onAnimationEnd(Animator animation) {
				if(child.getParent() != null){
					CellLayout layout = (CellLayout)child.getParent().getParent();
					layout.removeView(child);
				}
			}
			
			@Override
			public void onAnimationStart(Animator animation) {
			}
		});
		oa.start();
    }
    // Aurora <haojj> <2013-11-2> end
    
    private void animateFirstViewToPosition(final View child, final float translateX, long duration, long delay){
    	PropertyValuesHolder translateXHolder = PropertyValuesHolder.ofFloat("translationX", translateX, 0);

    	ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(child, translateXHolder);
		oa.setDuration(duration);
		oa.setStartDelay(delay);
		oa.addListener(new AnimatorListenerAdapter() {
			public void onAnimationEnd(Animator animation) {
				child.setTranslationX(0);
			}
			
			@Override
			public void onAnimationStart(Animator animation) {
				child.setVisibility(View.VISIBLE);
				// TODO Auto-generated method stub
				child.setTranslationX(translateX);
			}
		});
		oa.start();
    }
    
//    private void realTimeReorder(int[] empty, int[] target) {
//        boolean wrap;
//        int startX;
//        int endX;
//        int startY;
//        int delay = 0;
//        float delayAmount = 30;
//        CellLayout currentLayout = (CellLayout)mContent.getChildAt(mContent.getCurrentPage());
//        if (readingOrderGreaterThan(target, empty)) {
//            wrap = empty[0] >= currentLayout.getCountX() - 1;
//            startY = wrap ? empty[1] + 1 : empty[1];
//            for (int y = startY; y <= target[1]; y++) {
//                startX = y == empty[1] ? empty[0] + 1 : 0;
//                endX = y < target[1] ? currentLayout.getCountX() - 1 : target[0];
//                for (int x = startX; x <= endX; x++) {
//                    View v = currentLayout.getChildAt(x,y);
//                    if (currentLayout.animateChildToPosition(v, empty[0], empty[1],
//                            REORDER_ANIMATION_DURATION, delay, true, true)) {
//                        empty[0] = x;
//                        empty[1] = y;
//                        delay += delayAmount;
//                        delayAmount *= 0.9;
//                    }
//                }
//            }
//        } else {
//            wrap = empty[0] == 0;
//            startY = wrap ? empty[1] - 1 : empty[1];
//            for (int y = startY; y >= target[1]; y--) {
//                startX = y == empty[1] ? empty[0] - 1 : currentLayout.getCountX() - 1;
//                endX = y > target[1] ? 0 : target[0];
//                for (int x = startX; x >= endX; x--) {
//                    View v = currentLayout.getChildAt(x,y);
//                    if (currentLayout.animateChildToPosition(v, empty[0], empty[1],
//                            REORDER_ANIMATION_DURATION, delay, true, true)) {
//                        empty[0] = x;
//                        empty[1] = y;
//                        delay += delayAmount;
//                        delayAmount *= 0.9;
//                    }
//                }
//            }
//        }
//    }

    OnAlarmListener mOnExitAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            completeDragExit();
        }
    };
    
    void setForceNoCloseFolder(boolean open){
    	mForceNoClose = open;
    }

    public void completeDragExit() {
        if(mForceNoClose) {
        	mForceNoClose = false;
        } else {
        	mLauncher.closeFolder();
        }
        mCurrentDragInfo = null;
        mContent.setCurrentDragInfo(null);
        mCurrentDragView = null;
        mSuppressOnAdd = false;
        mOutDragOnAdd = false;
    }

    public void notifyDrop() {
        if (mDragInProgress) {
            mItemAddedBackToSelfViaIcon = true;
        }
    }

    public boolean isFull() {
        return mContent.isFull();
    }

    float getPivotXForIconAnimation() {
        return mFolderIconPivotX;
    }
    float getPivotYForIconAnimation() {
        return mFolderIconPivotY;
    }
    
    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mContent = (FolderWorkspace) findViewById(R.id.folder_content);
        mContent.setMotionEventSplittingEnabled(false);
        mContent.setFolderLongClickListener(this);
        mContent.setFolderClickListener(this);
        mContent.setBackgroundResource(R.drawable.folder_content_bg);
        mContent.getBackground().setAlpha(0);
        
        mFolderName = (FolderEditText) findViewById(R.id.folder_name);
        mFolderName.setFolder(this);
        // Aurora <haojj> <2013-10-2> add for 用于FolderEditText拖出时关闭文件夹 begin
        mFolderName.setLauncher(mLauncher);
        // Aurora <haojj> <2013-10-2> end
        mFolderName.setOnFocusChangeListener(this);

        // We disable action mode for now since it messes up the view on phones
        mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
        mFolderName.setOnEditorActionListener(this);
        mFolderName.setSelectAllOnFocus(true);
        mFolderName.setInputType(mFolderName.getInputType() |
                InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS);

        mIndicator = (FolderPageIndicator)findViewById(R.id.folder_indicator);
        mIndicator.initPoints(getContext(), 1);
    }
    
    public void initDragHintRects(){
    	int desireHeight = this.getMeasuredHeight();
    	//First set folder EditText hint rect
    	int folderNameT=mDeleteDropTargerHeight;
    	int folderNameB=mFolderContentTopInDragLayer+mFolderNameHeight;
    	mFolderName.setHitRect(0, folderNameT, mDisplayWidth, folderNameB);
    	//Second set Folder content hint rect
    	int mFolderContentHeightExpectFolderName =desireHeight -  mFolderNameHeight;
    	int mFolderContentB = folderNameB+mFolderContentHeightExpectFolderName;
    	this.setHitRect(0, folderNameB+1, mDisplayWidth, mFolderContentB);
    	//third set folder empty hint rect
    	FolderEmptyDropTarget folderEmptyDropTarget = (FolderEmptyDropTarget)getFolderEmptyDropTarget();
    	folderEmptyDropTarget.setHitRect(0, mFolderContentB+1, mDisplayWidth, mDisplayHeight);
    }
    
    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
    	super.onLayout(changed, l, t, r, b);
    	initDragHintRects();
    }
    
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    	int indicateHeight = mIndicator.getDesiredHeight();
    	
    	int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
        int height = getPaddingTop() + getPaddingBottom() + mContent.getDesiredHeight2() + mFolderNameHeight
        		 + indicateHeight + mEditTextMargin;

        int contentWidthSpec = MeasureSpec.makeMeasureSpec(mContent.getDesiredWidth(),
                MeasureSpec.EXACTLY);
        int contentHeightSpec = MeasureSpec.makeMeasureSpec(mContent.getDesiredHeight2(),
                MeasureSpec.EXACTLY);
        mContent.measure(contentWidthSpec, contentHeightSpec);

        mFolderName.measure(MeasureSpec.makeMeasureSpec(mFolderNameWidth, MeasureSpec.EXACTLY),
              MeasureSpec.makeMeasureSpec(mFolderNameHeight, MeasureSpec.EXACTLY));
        		
        mIndicator.measure(MeasureSpec.makeMeasureSpec(mIndicator.getDesiredWidth(), MeasureSpec.EXACTLY), 
        		MeasureSpec.makeMeasureSpec(indicateHeight, MeasureSpec.EXACTLY));
        
        setMeasuredDimension(width, height);
    }

    private void centerAboutIcon() {
        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
        int height = getPaddingTop() + getPaddingBottom() + mContent.getDesiredHeight2()
                + mFolderNameHeight + mIndicator.getDesiredHeight() + mEditTextMargin;
        int currentPage = mLauncher.getWorkspace().getCurrentPage();
        // In case the workspace is scrolling, we need to use the final scroll to compute
        // the folders bounds.
        mLauncher.getWorkspace().setFinalScrollForPageChange(currentPage);
        lp.width = width;
        lp.height = height;
        lp.x = 0;
        //lp.y = 216;
        lp.y = mFolderContentTopInDragLayer;
    }
    
    public int getItemCount() {
        return mContent.getItemCount();
    }
    
    public FolderWorkspace getFolderWorkspace(){
    	return mContent;
    }
    
    public void snapToDestination(){
    	mContent.snapToDestination();
    }
    
    private void onCloseComplete() {
        DragLayer parent = (DragLayer) getParent();
        if (parent != null) {
            parent.removeView(this);
        }

        mDragController.removeDropTarget((DropTarget) this);
        // Aurora <haojj> <2013-10-1> add for ACCESSIBILITY_SERVICE begin
        mDragController.removeDropTarget((DropTarget)getEditTextRegion());
        mDragController.removeDropTarget(getFolderEmptyDropTarget());
     	// Aurora <haojj> <2013-10-1> end
        
        clearFocus();
        mFolderIcon.requestFocus();

        if (getItemCount() <= 1) {
        	//Log.e("HJJ", "====onclosecomplete + mDragInProgress:" + mDragInProgress + ",mSuppressFolderDeletion:" + mSuppressFolderDeletion);
            if (!mDragInProgress && !mSuppressFolderDeletion) {
            	//Log.e("HJJ", "====onclosecomplete execute...");
                replaceFolderWithFinalItem();
            } else if (mDragInProgress) {
                mDeleteFolderOnDropCompleted = true;
            }
        }
        mSuppressFolderDeletion = false;
    }

    private void replaceFolderWithFinalItem() {
        // Add the last remaining child to the workspace in place of the folder
        Runnable onCompleteRunnable = new Runnable() {
            @Override
            public void run() {
                CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screen);

               View child = null;
               
               Log.d("vulcan-empfld",
               		String.format("3: itemCount = %d", getItemCount()));
                // Move the item from the folder to the workspace, in the position of the folder
                if (getItemCount() == 1) {
					if (mInfo != null && mInfo.contents != null
							&& !mInfo.contents.isEmpty()) {
						ShortcutInfo finalItem = mInfo.contents.get(0);
						child = mLauncher.createShortcut(R.layout.application,
								cellLayout, finalItem);
						LauncherModel.addOrMoveItemInDatabase(mLauncher,
								finalItem, mInfo.container, mInfo.screen,
								mInfo.cellX, mInfo.cellY);
					}
                }
                if (getItemCount() <= 1) {
                    // Remove the folder
                    LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
                    cellLayout.removeView(mFolderIcon);
                    if (mFolderIcon instanceof DropTarget) {
                        mDragController.removeDropTarget((DropTarget) mFolderIcon);
                    }
                    mLauncher.removeFolder(mInfo);
                    // 回收哪个＋号
                    mContent.recycleFolderAddView();
                }
                // We add the child after removing the folder to prevent both from existing at
                // the same time in the CellLayout.
                if (child != null) {
                	boolean check = false;
                	ShortcutInfo sh = (ShortcutInfo) child.getTag();
                	List<ShortcutInfo> slist = mLauncher.getWorkspace().getRemoveViewList();
                	if(slist != null){
                		for(ShortcutInfo f : slist){
                			if(f == sh){
                				check = true;
                				break;
                			}
                		}
                	}
                	
                	if(!check){
                    	mLauncher.getWorkspace().addInScreen(child, mInfo.container, mInfo.screen,
                                mInfo.cellX, mInfo.cellY, mInfo.spanX, mInfo.spanY);
                	}
                	
                	/*mLauncher.getWorkspace().addInScreen(child, mInfo.container, mInfo.screen,
                            mInfo.cellX, mInfo.cellY, mInfo.spanX, mInfo.spanY);*/
                }
            }
        };
        View finalChild = mContent.getItemAt(0, 0);
        
        Log.d("vulcan-empfld",
        		String.format("2: finalChild = %s", finalChild));
        if (finalChild != null) {
        	// Aurora <jialf> <2014-01-26> modify for delete folder begin
        	onCompleteRunnable.run();
            // mFolderIcon.performDestroyAnimation(finalChild, onCompleteRunnable);
        	// Aurora <jialf> <2014-01-26> modify for delete folder end
        } 
        // Aurora <haojj> <2013-9-14> add for perform when folder have no items begin
        else if(isImportMode()){
        	onCompleteRunnable.run();
        }
        else {
        	onCompleteRunnable.run();
        }
        // Aurora <haojj> <2013-9-14> end
        mDestroyed = true;
    }

    boolean isDestroyed() {
        return mDestroyed;
    }

    // This method keeps track of the last item in the folder for the purposes
    // of keyboard focus
    private void updateTextViewFocus() {
        View lastChild = mContent.getItemAt(0);
        if (lastChild != null) {
            mFolderName.setNextFocusDownId(lastChild.getId());
            mFolderName.setNextFocusRightId(lastChild.getId());
            mFolderName.setNextFocusLeftId(lastChild.getId());
            mFolderName.setNextFocusUpId(lastChild.getId());
        }
    }

    void bind(FolderInfo info) {
        mInfo = info;
        mContent.bindWorkspace(info);
 
        updateTextViewFocus();
        mInfo.addListener(this);
        setFolderDefaultName();
        if (!TextUtils.isEmpty(mInfo.title) && !sDefaultFolderName.contentEquals(mInfo.title)) {
            mFolderName.setText(mInfo.title);
        } else {
            mFolderName.setText(sDefaultFolderName);
        }
    }
    
    public void onAdd(ShortcutInfo item) {
    	//Log.e("HJJ", "====Folder onAdd");
        // If the item was dropped onto this open folder, we have done the work associated
        // with adding the item to the folder, as indicated by mSuppressOnAdd being set
        if (mSuppressOnAdd) return;
        if (mOutDragOnAdd){
        	mContent.onAdd(item, mEmptyCell);
        } else {
			// mContent.detachFolderAddView(false);
        	// 此处即使addview在(0,0)位置也可以认为其没必要将将layout移除，因为立即要添加新的item
        	mContent.onlyDetachFolderAddView();
			mContent.onAdd(item);
        }
        // 如果Folder不是DragSource则不会使用onDropComplete
     	mContent.attachFolderAddView(false, 0, 0);
    }

	@Override
	public void onMultiAdd(ArrayList<ShortcutInfo> items) {
		// TODO Auto-generated method stub
        mContent.detachFolderAddView(false);
    	mContent.onMultiAdd(items);
    	initAddItemsInLastLayout(items);
    	// 因为onAdd有可以不会使用onDropComplete
    	mContent.attachFolderAddView(false, 0, 0);
	}

	@Override
	public void onMultiRemove(ArrayList<ShortcutInfo> items) {
		mContent.detachFolderAddView(false);
		
		mContent.onMultiRemove(items);
		
		if (getItemCount() <= 1) {
			replaceFolderWithFinalItem();
		} else {
			// 当添加icon到文件夹时，执行了移除操作，但并没有执行添加操作，结果会导致＋号icon丢失
			mContent.attachFolderAddView(false, 0, 0);
		}
	}
	
    public void onRemove(ShortcutInfo item) {
    	//Log.e("HJJ", "====Folder onRemove");
    	mContent.detachFolderAddView(false);
        // If this item is being dragged from this open folder, we have already handled
        // the work associated with removing the item, so we don't have to do anything here.
        if (item == mCurrentDragInfo) return;
        mContent.onRemove(item);
        Log.d("vulcan-empfld",String.format("1: item: %s(%d), mShowAddViewAfterUnload = %b", item.title, getItemCount(), mShowAddViewAfterUnload));
        if (getItemCount() <= 1) {
        	// Aurora <haojj> <2013-10-18> add for BUG #103 卸载后如果只有一个icon，应该关闭文件夹 begin
        	if(mShowAddViewAfterUnload){
        		mShowAddViewAfterUnload = false;
        		if(mInfo.opened){
        			mSuppressFolderDeletion = false;
        			mLauncher.closeFolderNoAnimate(this);
        		} else {
        			replaceFolderWithFinalItem();
        		}
        	} else {
        		replaceFolderWithFinalItem();
        	}
        	// Aurora <haojj> <2013-10-18> end
        }
        // Aurora <haojj> <2013-10-2> add for 处理卸载程序后的添加显示 begin
        if(mShowAddViewAfterUnload){
        	mContent.attachFolderAddView(false, 0, 0);
        	mShowAddViewAfterUnload = false;
        }
        // Aurora <haojj> <2013-10-2> end
    }
    
	/**
	 * vulcan created and tested it in 2014-6-20
	 * if there is a dynamic icon in the folder, it should be a dynamic folder
	 */
    private boolean folderShouldBeDynamic() {
    	if(mFolderIcon == null) {
    		return false;
    	}
		ArrayList<View> previewList = mFolderIcon.getDynPreviewItems();//it must be not null
		int prvCnt = previewList.size();
		BubbleTextView subIcon = null;
		Drawable drawable = null;
		for(int i=0;i < prvCnt; i ++) {
			subIcon = (BubbleTextView)previewList.get(i);
			if(subIcon.mDynIconPlg != null) {
				return true;
			}
		}
		return false;
    }
    
    public void onItemsChanged() {
        updateTextViewFocus();
        
        Log.d("vulcan-iconlist","onItemsChanged>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
  
        //vulcan created it in 2014-6-19
        //after refreshPreviewIcon,
        //re-consider if this folder should be dynamic, because items in this folder has changed
		if (mFolderIcon != null) {
			mFolderIcon.refreshDynPreviewIcon();
			if(mFolderIcon.getDynPreviewItems().size() > 0) {
				if(mFolderIcon.mDynIconPlg == null) {
					mFolderIcon.mDynIconPlg = DynIconPlg.produceDynIconPlg(mInfo, mFolderIcon);
					if(mFolderIcon.mDynIconPlg != null) {
						DynIconPlg.addDynIcon(mFolderIcon.mDynIconPlg);
					}
				}
				
			}
			else {
				if(mFolderIcon.mDynIconPlg != null) {
					DynIconPlg.rmDynIcon(mFolderIcon.mDynIconPlg);
					mFolderIcon.mDynIconPlg = null;
				}
			}
		}
        
        
        //vulcan created it in 2014-6-19
        //Dynamic icon status has changed, so we notify the DynIconDriver module
        if(mLauncher != null) {
        	Workspace w = mLauncher.getWorkspace();
			if (w != null) {
				DynIconDriver.setHotseatSwitch(w.hotseatHasDynamicIcon());
				Log.d("vulcan-iconop","onItemsChanged: w.hotseatHasDynamicIcon()=" + w.hotseatHasDynamicIcon());
				View curPageView = w.getPageAt(w.getCurrentPage());
				if (curPageView != null) {
					DynIconDriver.setDesktopSwitch(w.desktopHasDynamicIcon(curPageView));
					Log.d("vulcan-iconop","onItemsChanged: desktopHasDynamicIcon(curPageView):" + w.desktopHasDynamicIcon(curPageView));
				}
			}
        }

        Log.d("vulcan-iconlist","onItemsChanged<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
        

    }

    public void onTitleChanged(CharSequence title) {
    }

    public void getLocationInDragLayer(int[] loc) {
//        mLauncher.getDragLayer().getLocationInDragLayer(this, loc, true);
        mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
    }

    public void onFocusChange(View v, boolean hasFocus) {
        if (v == mFolderName && hasFocus) {
            startEditingFolderName();
        }
    }
    
	public ArrayList<View> getItemsInReadingOrder() {
        return getItemsInReadingOrder(true);
    }

    public ArrayList<View> getItemsInReadingOrder(boolean includeCurrentDragItem) {
    	return mContent.getItemsInReadingOrder(0, includeCurrentDragItem);
    }

	public boolean appNotExists(ItemInfo info) {
		if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
			ShortcutInfo item = (ShortcutInfo) info;
			ComponentName cn = item.intent.getComponent();
			List<ResolveInfo> list = AllAppsList.findActivitiesForPackage(
					getContext(), cn.getPackageName());
			return list.size() == 0;
		}
		return false;
	}
    
	// DragSource方法
	@Override
    public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
            boolean success) {
		//Log.e("HJJ", "====Folder onDropCompleted, open:" + mInfo.opened);
		Log.d("vulcan-crash", "onDropCompleted: acceptDrop = false, success = " + success);
		mReorderAlarm.cancelAlarm();
        if (success) {
        	ItemInfo info = (ItemInfo)d.dragInfo;
			if (((info.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) || appNotExists(info)) 
					&& mInfo.opened && getItemCount() <= 1){
        		mDragInProgress = false;
        		mLauncher.closeFolderNoAnimate(this);
        		return;
        	} else {
		        if (mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon) {
		        	if(getItemCount()<=1){
		        		replaceFolderWithFinalItem();
		        	}
		        }
        	}
        } else {
            // The drag failed, we need to return the item to the folder
        	if(target instanceof DeleteDropTarget){
        		mLauncher.setFolderIcon(mFolderIcon);
        		mFolderIcon.onDrop(d, false); //文件夹拖拽删除，不建议显示。。。。。//DragObject d被拖拽的对象
        	} else {
        		if(target != null && target.getParent() != null && mLauncher.isHotseatLayout((View)target.getParent().getParent())){
        			mFolderIcon.notifyDropOnDock();
        		}
        		// Aurora <jialf> <2014-02-11> modify for fix bug #2165 begin
        		mLauncher.getWorkspace().updateAuroraHoseatDataFromFolder();
        		// Aurora <jialf> <2014-02-11> modify for fix bug #2165 end
        		mFolderIcon.onDrop(d);
        	}

            // 这是因为在folder外面没有找到合适的drop，因此又回到原来的folder，但如果此时文件夹中只有一个item的话，
            // 就需要设置mSuppressFolderDeletion，否则的话将有可能被删除
            // We're going to trigger a "closeFolder" which may occur before this item has
            // been added back to the folder -- this could cause the folder to be deleted
            if (mOnExitAlarm.alarmPending()) {
                mSuppressFolderDeletion = true;
            }
        }

        if (target != this) {
            if (mOnExitAlarm.alarmPending()) {
                mOnExitAlarm.cancelAlarm();
                completeDragExit();
            }
        }
        mDeleteFolderOnDropCompleted = false;
        mDragInProgress = false;
        mItemAddedBackToSelfViaIcon = false;
        mCurrentDragInfo = null;
        mContent.setCurrentDragInfo(mCurrentDragInfo);
        mCurrentDragView = null;
        mSuppressOnAdd = false;

		// Aurora <jialf> <2014-02-11> modify for fix bug #2165 begin
        if(getItemCount() > 1) {
        	mContent.settleChildrenView();
        	mContent.updateItemLocationsInDatabase(); 
        }
		// Aurora <jialf> <2014-02-11> modify for fix bug #2165 end
         
        // 只要一移动肯定有这个的,因此只需要在此进行显示就好
        //mContent.attachFolderAddView(false, 0, 0);
        //setNameAndContentBg(false, false, true);
		
        //iht AURORA_START 2015-01-06
        //先将背景消失，然后凸显[+]，避免闪现；
        setNameAndContentBg(false, false, true);
        postDelayed(new Runnable() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				mContent.attachFolderAddView(false, 0, 0);
			}
		}, 200);
        //AURORA_END
        
        // Aurora <haojj> <2013-9-22> add for 当拖动出folder时此时放下应该退出编辑模式 begin
        // !(target instanceof Folder) 用于解决图标从文件夹A拖出并打开文件夹B，这时放下图标时，因文件夹仍需打开故不执行reverseNormal
        // (d.dragSource == target) 用于解决图标从文件夹拖出并fling该图标，该图标又回到了文件夹，但应执行reverseNormal，该bug＠加林峰知道
        // 如果出现问题请回转到if (!mInfo.opened && (!(target instanceof Folder))
        if (!mInfo.opened && (!(target instanceof Folder) || (d.dragSource == target))) {
        	mLauncher.reverseNormal();
        } else if((mInfo.opened || mLauncher.getWorkspace().getFolderOpenState()) && (d.dragSource instanceof Folder)){
        	if(target instanceof Folder && target != this){
        		((Folder) target).setContentBg(false);
        	}
        	LauncherApplication.logVulcan.print("onDropCompleted: to call mLauncher.exitEditMode!");
        	mLauncher.setFromFolderDrop(true);
        	mLauncher.exitEditMode(true);
        } 
        // Aurora <haojj> <2013-9-22> end
    }

	@Override
	public boolean supportsFlingToDelete() {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void onFlingToDeleteCompleted() {
		// TODO Auto-generated method stub
	}

	// DropTarget方法
	@Override
	public boolean isDropEnabled() {
		// TODO Auto-generated method stub
		return true;
	}

	@Override
	public void onDrop(DragObject d) {
		// TODO Auto-generated method stub
//		Log.e("HJJ", "====Folder onDrop");
        ShortcutInfo item;
        if (d.dragInfo instanceof ApplicationInfo) {
            // Came from all apps -- make a copy
            item = ((ApplicationInfo) d.dragInfo).makeShortcut();
            item.spanX = 1;
            item.spanY = 1;
        } else {
            item = (ShortcutInfo) d.dragInfo;
        }
        // Dragged from self onto self, currently this is the only path possible, however
        // we keep this as a distinct code path.
        if (item == mCurrentDragInfo) {
            ShortcutInfo si = (ShortcutInfo) mCurrentDragView.getTag();
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) mCurrentDragView.getLayoutParams();
            si.cellX = lp.cellX = mEmptyCell[0];
            si.cellY = lp.cellY = mEmptyCell[1];
            // Aurora <haojj> <2013-9-24> add for update screen begin
            item.screen = mEmptyCell[2];
            // Aurora <haojj> <2013-9-24> end
            CellLayout layout = (CellLayout)mContent.getChildAt(item.screen);
            /* begin add by xiangzx for bug 16471 in 2015/09/16 */ 
            if(mCurrentDragView.getParent() != null){
              ViewGroup parent =(ViewGroup) mCurrentDragView.getParent();
              parent.removeView(mCurrentDragView);
              mInfo.remove(item);
            }
            /* end add by xiangzx for bug 16471 in 2015/09/16 */ 
            layout.addViewToCellLayout(mCurrentDragView, -1, (int)item.id, lp, true);
            if (d.dragView.hasDrawn()) {
            	d.deferDragViewCleanupPostAnimation = true;
            	d.cleanDragViewForFolder = true;
                mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, mCurrentDragView);
            } else {
                d.deferDragViewCleanupPostAnimation = false;
                mCurrentDragView.setVisibility(VISIBLE);
            }
            
            // 这里暂时不做onDragOver的处理，因此无需做些操作
            // setupContentDimensions(getItemCount());
            mSuppressOnAdd = true;
        }
        // Aurora <haojj> <2013-10-2> add for 当将item从workspace拖动到文件夹放下时删除框不会消失 begin
        else {
        	d.deferDragViewCleanupPostAnimation = false;

        	// Aurora <jialf> <2013-10-15> add for Dock data begin
        	ShortcutInfo info = (ShortcutInfo) d.dragInfo;
        	Workspace space = mLauncher.getWorkspace();
			// Aurora <jialf> <2013-10-31> modify for fix bug #313 begin
			if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT
					//hotseat5
					//&& space.ismAuroraSwapTag()
					) {
			// Aurora <jialf> <2013-10-31> modify for fix bug #313 end
				ShortcutAndWidgetContainer sac = mLauncher.getHotseat()
						.getLayout().getShortcutsAndWidgets();
				space.updateAuroraMemoryParams(info,sac);
				final CellLayout parentLayout = mLauncher.getHotseat().getLayout();
				parentLayout.setAuroraCellX(false);
				parentLayout.setAuroraGridSize(-1);
				space.updateHotseatData();
				space.resetAuroraHotseatData();
			}
        	// Aurora <jialf> <2013-10-15> add for Dock data end
        }
        mOpenFolderAndDrag = false;
        // Aurora <haojj> <2013-10-2> end
        mInfo.add(item);
        if(!(d.dragSource instanceof Folder)){
        	setNameAndContentBg(false, false, true);
        	mContent.updateItemLocationsInDatabase();
        }
        setParamsAndCenter();
	}

    private void dragEnterReorder(int[] empty, int[] target, int targetPage) {
        boolean wrap;
        int startX;
        int endX;
        int startY;
        int endY;
        int delay = 0;
        float delayAmount = 30;
        int finalX = FolderWorkspace.DEFAULT_CELL_COUNT_X - 1;
       	int finalY = FolderWorkspace.DEFAULT_CELL_COUNT_Y - 1;
       	final int emptyPage = empty[2];
       	
    	for(int page = emptyPage; page >= targetPage; page--){
    		CellLayout currentLayout = (CellLayout) mContent.getChildAt(page);
        	wrap = empty[0] == 0;
            startY = (page == emptyPage) ? (wrap ? empty[1] - 1 : empty[1]) : finalY;
            endY = (page == targetPage) ? target[1] : 0;
            for (int y = startY; y >= endY; y--) {
                startX = (page == emptyPage) ? (y == empty[1] ? empty[0] - 1 : finalX) : finalX;
                endX = (page == targetPage) ? (y > target[1] ? 0 : target[0]) : 0;
                for (int x = startX; x >= endX; x--) {
                    View v = currentLayout.getChildAt(x,y);
                    if (currentLayout.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
            int prevPage = page - 1;
            if(prevPage >= targetPage){
            	CellLayout prevLayout = (CellLayout) mContent.getChildAt(prevPage);
            	View lastView = prevLayout.getChildAt(finalX, finalY);
            	prevLayout.removeView(lastView);
            	if(null == lastView) {
            		empty[0] = finalX;
                    empty[1] = finalY;
                    empty[2] = prevPage;
            		continue;
            	}
            	
            	CellLayout.LayoutParams lp = new CellLayout.LayoutParams(0,
            			0, 1, 1);
            	ItemInfo item = (ItemInfo)lastView.getTag();
        		if(currentLayout.addViewToCellLayout(lastView, -1, (int) item.id,
        				lp, true)){
        			empty[0] = finalX;
                    empty[1] = finalY;
                    empty[2] = prevPage;
        		}
            }
    	}
    }
	
	@Override
	public void onDragEnter(DragObject d) {
		//Log.e("HJJ", "=====Folder onDragEnter");
		// Aurora <haojj> <2013-10-8> add for 如果不添加这句话，迅速移动icon到删除区域又迅速移动icon到文件夹区域将退出folder这是不合理的 begin
		mOnExitAlarm.cancelAlarm();
		// Aurora <haojj> <2013-10-8> end
		if(mDragUseLongClick) {
			mDragUseLongClick = false;
			mOutDragOnAdd = false;
	        mPreviousTargetCell[0] = -1;
	        mPreviousTargetCell[1] = -1;
	        mPreviousPage = mContent.getCurrentPage();
	        mOnExitAlarm.cancelAlarm();
		} else {
			if(mReorderAlarm.alarmPending()){
				mReorderAlarm.cancelAlarm();
				return;
			}
			mOutDragOnAdd = true;
			// onDragExit发生在onDrop的前面，因此要注意如果show的使用
			// mContent.detachFolderAddView(false);
			mContent.onlyDetachFolderAddView();
			
			float[] r = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView, null);
			mTargetPage = mContent.getCurrentPage();
			CellLayout currentLayout = (CellLayout)mContent.getChildAt(mTargetPage);
	        mTargetCell = currentLayout.findNearestArea((int) r[0], (int) r[1], 1, 1, mTargetCell);
	        
	        final int lastPage = mContent.getChildCount() - 1;
	        int[] tempEmptyCell = new int[2];
			CellLayout layout = (CellLayout) mContent.getChildAt(lastPage);
			layout.findCellForSpan(tempEmptyCell, 1, 1);
			
			mEmptyCell[0] = tempEmptyCell[0];
			mEmptyCell[1] = tempEmptyCell[1];
			mEmptyCell[2] = lastPage;
			
			dragEnterReorder(mEmptyCell, mTargetCell, mTargetPage);
		}
	}

	@Override
	public void onDragOver(DragObject d) {
		// TODO Auto-generated method stub
		float[] r = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView, null);
		mTargetPage = mContent.getCurrentPage();
		CellLayout currentLayout = (CellLayout)mContent.getChildAt(mTargetPage);
        mTargetCell = currentLayout.findNearestArea((int) r[0], (int) r[1], 1, 1, mTargetCell);

        //Log.e("HJJ", "[111]mTargetCell==>x:" + mTargetCell[0] + ",y:" + mTargetCell[1] + ";mPreviousTargetCell==>x:" + mPreviousTargetCell[0] + ",y:" + mPreviousTargetCell[1]);
        if (mTargetPage != mPreviousPage || mTargetCell[0] != mPreviousTargetCell[0] || mTargetCell[1] != mPreviousTargetCell[1]) {
            mReorderAlarm.cancelAlarm();
            mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
            mReorderAlarm.setAlarm(150); 
            // Aurora <haojj> <2013-9-24> add for judge page update begin
            mPreviousPage = mTargetPage;
			// Aurora <haojj> <2013-9-24> end
            mPreviousTargetCell[0] = mTargetCell[0];
            mPreviousTargetCell[1] = mTargetCell[1];
        }
	}

    // This is used to compute the visual center of the dragView. The idea is that
    // the visual center represents the user's interpretation of where the item is, and hence
    // is the appropriate point to use when determining drop location.
    private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
            DragView dragView, float[] recycle) {
        float res[];
        if (recycle == null) {
            res = new float[2];
        } else {
            res = recycle;
        }

        // These represent the visual top and left of drag view if a dragRect was provided.
        // If a dragRect was not provided, then they correspond to the actual view left and
        // top, as the dragRect is in that case taken to be the entire dragView.
        // R.dimen.dragViewOffsetY.
        int left = x - xOffset;
        // Aurora <haojj> <2013-9-22> add for removing statusbar  at full-screen height begin
        int top = y - yOffset - mLauncher.getStatusBarHeight();
        // Aurora <haojj> <2013-9-22> end

        // In order to find the visual center, we shift by half the dragRect
        res[0] = left + dragView.getDragRegion().width() / 2;
        res[1] = top + dragView.getDragRegion().height() / 2;

        return res;
    }
    
    OnAlarmListener mOnArrangeAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
        	realTimeReorder(mEmptyCell, mTargetCell, mTargetPage);
        	// 该代码不能去掉，如果去掉会出现＋号丢失的现象
        	mContent.attachFolderAddView(true, REORDER_ANIMATION_DURATION, 30);
        }
    };
    
	@Override
	public void onDragExit(DragObject d) {
		//Log.e("HJJ", "=====Folder onDragExit........");
		// TODO Auto-generated method stub
	    // We only close the folder if this is a true drag exit, ie. not because a drop
        // has occurred above the folder.
		mReorderAlarm.cancelAlarm();
        if (!d.dragComplete) {
        	final int lastPageIndex = mContent.getChildCount() - 1;
        	if(mTargetPage == lastPageIndex) {
        		mTargetCell[0] = FolderWorkspace.INDEX_MAX_CELL_COUNT_X;
        		mTargetCell[1] = FolderWorkspace.INDEX_MAX_CELL_COUNT_Y;
        	} else {
        		mTargetPage = lastPageIndex;
        		CellLayout layout = (CellLayout) mContent.getChildAt(mTargetPage);
        		layout.findCellForSpan(mTargetCell, 1, 1);
        	}
    		// Toast.makeText(getContext(), "mTargetPage:" + mTargetPage + "mTargetCell(" + mTargetCell[0] + "," + mTargetCell[1] + ")", Toast.LENGTH_SHORT).show();
    		
        	mReorderAlarm.setOnAlarmListener(mOnArrangeAlarmListener);
            mReorderAlarm.setAlarm(300); 
        	
            // 当桌面上的文件夹第二屏只有一个图标的时候，拖动该图标到Dock栏位置立即拖动到文件夹，此时概率性出现该图标丢失的现象。
            // 出现此问题的原因在于，mOutDragOnAdd（该变量表示拖动的对象是从覆盖文件夹后打开文件夹进来的），由于关闭文件夹会有一定的时延，
            // 本来onDragExit响应的时候mOutDragOnAdd应该设为false，但由于调用mOnExitAlarmListener有一定的时延，而此时恰好添加item的话调用到onAdd时，
            // 按mOutDragOnAdd＝true执行;最终导致图标丢失，因此，onDragExit时我立即调用了mOutDragOnAdd=false
            mOutDragOnAdd = false;
            mOnExitAlarm.setOnAlarmListener(mOnExitAlarmListener);
            mOnExitAlarm.setAlarm(ON_EXIT_CLOSE_DELAY);
        } 
	}

	@Override
	public void onFlingToDelete(DragObject dragObject, int x, int y, PointF vec) {
		// TODO Auto-generated method stub
	}

	@Override
	public DropTarget getDropTargetDelegate(DragObject dragObject) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean acceptDrop(DragObject d) {
		// TODO Auto-generated method stub
		final ItemInfo item = (ItemInfo) d.dragInfo;
        final int itemType = item.itemType;
        //AURORA-START:xiejun:20130923:ID138
        d.cleanDragViewForFolder=false;
        //AURORA-END:xiejun:20130923:ID138
        return ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
                    itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) &&
                    !isFull());
	}

	private boolean isImportMode(){
		return mLauncher.getEditMode() == EditMode.FOLDER_IMPORT;
	}
	
	private boolean mDragUseLongClick = false;
	@Override
	public boolean onLongClick(View v) {
		// TODO Auto-generated method stub
		//add by xiexiujie for calender plugin icon start 10.13
		 if(mLauncher.layout!=null&& mLauncher.layout.getParent()!=null){
       	  CellLayout	layout=	(CellLayout) mLauncher.layout.getParent().getParent();
  			layout.removeView(mLauncher.layout);    		
         } 
		 View view = (View) v.getParent().getParent();
	 		CellLayout.CellInfo cellInfo = (CellLayout.CellInfo) view
	 				.getTag();
	 		if(cellInfo.cell instanceof CalenderPlugin){	 		
	 			return false;
	 		} 
		//add by xiexiujie for calender plugin icon end 10.13
		if(mLauncher.getEditMode() == EditMode.CLASSIFICATE_ICONS)return true;
		
		if (!mLauncher.isDraggingEnabled()) return true;
		// Aurora <haojj> <2013-9-22> add for no longclick event when importing folder begin
		if (isImportMode()) return true;
		// Aurora <haojj> <2013-9-22> end

        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            ShortcutInfo item = (ShortcutInfo) tag;
            if (!v.isInTouchMode()) {
                return false;
            }
            
            mLauncher.resetAuroraUninstallData();

            mLauncher.dismissFolderCling(null);
            // Aurora <haojj> <2013-9-16> add for [1]make deleteRegion  [2] show backgroud to front begin
            setNameAndContentBg(true, false);
			// Aurora <haojj> <2013-9-16> end

            mDragUseLongClick = true;
            
            // Aurora <haojj> <2013-10-10> add for 模仿launcher onlongclick来实现拖动逻辑的逻辑 begin
            View layout = (View) v.getParent().getParent();
    		CellLayout.CellInfo longClickCellInfo = (CellLayout.CellInfo) layout
    				.getTag();
    		mLauncher.createNewPage();
    		mLauncher.getWorkspace().startDragWithSource(longClickCellInfo, this);
    		//mLauncher.getWorkspace().onDragStartedWithItem(v);
            //mLauncher.getWorkspace().beginDragShared(v, this);
    		// Aurora <haojj> <2013-10-10> end
    		
    		//AURORA-START::Fix bug #3845::Shi guiqiang::20140403
    		mLauncher.toPlayThumnailLongClickAnimator(true);
    		int curpage = mLauncher.getWorkspace().getCurrentPage();
    		mLauncher.getPreviewContent().movetoItem(curpage);
    		mLauncher.setPreviewBarScroll(curpage);
    		//AURORA-END::Fix bug #3845::Shi guiqiang::20140403
            
            mIconDrawable = ((TextView) v).getCompoundDrawables()[1];

            mCurrentDragInfo = item;
            mContent.setCurrentDragInfo(mCurrentDragInfo);
            mEmptyCell[0] = item.cellX;
            mEmptyCell[1] = item.cellY;
            // Aurora <haojj> <2013-9-24> add for saving original screen begin
            mEmptyCell[2] = item.screen;
            // Aurora <haojj> <2013-9-24> end
            mCurrentDragView = v;

            mContent.removeViewAtPage(item.screen, mCurrentDragView);
            mInfo.remove(mCurrentDragInfo);
            
            mDragInProgress = true;
            mItemAddedBackToSelfViaIcon = false;
        }
		return true;
	}

	protected Animator animateFolderIcon(int duration, Interpolator in){
		ValueAnimator va = LauncherAnimUtils.ofFloat(1.0f, ALPHA_EDITED_FOLDER);
        va.addUpdateListener(new AnimatorUpdateListener(){
            public void onAnimationUpdate(ValueAnimator animation) {
                float progress = (Float) animation.getAnimatedValue();
                mFolderIcon.setAlpha(progress);
            }
        });
        /*va.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
            }
            @Override
            public void onAnimationEnd(Animator animation) {
            }
        });*/
        va.setDuration(duration);
        va.setInterpolator(in);
        //va.start();
        return va;
	}
	
	@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
//		Toast.makeText(getContext(), "onclick.....", Toast.LENGTH_SHORT).show();
		Object tag = v.getTag();
		if(mLauncher.getEditMode() == EditMode.CLASSIFICATE_ICONS){
			if(tag instanceof CellLayout.CellInfo){
					mLauncher.closeFolder();
				}
			return;
		}
		
		if(tag instanceof FolderWorkspace.FolderAddInfo){
			if(!isImportMode() && !mLauncher.isHomeKeyPress()){
				//animateFolderIcon();
				mLauncher.clearShortcutToFolder();
				mLauncher.setAndEnterEditMode(mInfo, mFolderIcon, mContent.getImportItemsMaxCount());
				if (isEditingName()) {
					dismissEditingName();
				}
				mLauncher.closeFolder(this, false, true);
		        mCurrentDragInfo = null;
		        mCurrentDragView = null;
		        mSuppressOnAdd = false;
		        mOutDragOnAdd = false;
			}
			mLauncher.setHomeKeyVal(false);
			return;
		}

		if (tag instanceof ShortcutInfo) {
			if (isImportMode()) {
				if (v instanceof BubbleTextView) {
					BubbleTextView bView = (BubbleTextView) v;
					if (bView.isChecked()) {
						mInfo.removeCheckInfos((ShortcutInfo) tag);
						mCheckedViews.remove(bView);
						if(mCheckedViews.size() == 0){
							mLauncher.removeCheckedFolderInfosItems(mInfo);
						}
					} else {
						if(mLauncher.getRemainImportItemsCount() <= 0) {
							Toast.makeText(mLauncher, R.string.folder_import_full_toast,
									Toast.LENGTH_SHORT).show();
							return;
						}
						mCheckedViews.add(bView);
						mInfo.addCheckInfos((ShortcutInfo) tag);
						mLauncher.addCheckedFolderInfo(mInfo);
					}
					mFolderIcon.invalidate();
					bView.setChecked();
					mLauncher.setImportFolderText(false);
				}
			} else {
				// refactor this code from Folder
				ShortcutInfo item = (ShortcutInfo) tag;
				int[] pos = new int[2];
				v.getLocationOnScreen(pos);
				item.intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0]
						+ v.getWidth(), pos[1] + v.getHeight()));
				LauncherApplication.logVulcan.print("onClick: setSourceBounds item = " + item.intent.toUri(0));

				// Aurora <haojj> <2013-10-9> add for remove new App标识 begin
				boolean success = mLauncher.startActivitySafely(v, item.intent, item);
				if (success && v instanceof BubbleTextView) {
					((BubbleTextView) v).setNewApp(false);
					item.newFlag = false;
				}
				// Aurora <haojj> <2013-10-9> end
			}	
		}
		//AURORA-START:xiejun:20130923:ID139
		else{
			mLauncher.closeFolder();
		}
		//AURORA-END:xiejun:20130923:ID139
	}

	@Override
	public void getHitRect(Rect outRect) {
		// TODO Auto-generated method stub
		//outRect.set(0, 361, 1080, 1650);
		outRect.set(mRect);
		Log.i("hitRect"," outRect ="+outRect);
	}
	private Rect mRect = new Rect();;
	public void setHitRect(int left,int top,int right,int bottom){
		mRect.set(left, top, right, bottom);
	}
	
	@Override
	public void onClearChecked() {
		// TODO Auto-generated method stub
		if(mCheckedViews != null) {
			for(int i=0;i<mCheckedViews.size();i++){
				mCheckedViews.get(i).setChecked(false);
        	}
			mCheckedViews.clear();
		}
	}

	@Override
	public void scrollLeft() {
		// TODO Auto-generated method stub
		mContent.scrollLeft();
	}

	@Override
	public void scrollRight() {
		// TODO Auto-generated method stub
		mContent.scrollRight();
	}

	@Override
	public boolean onEnterScrollArea(int x, int y, int direction) {
		// TODO Auto-generated method stub
		mInScrollArea = true;
		int nextPage = mContent.getNextPage();
		final int page = nextPage +
                (direction == DragController.SCROLL_LEFT ? -1 : 1);
		int sum = mContent.getPageCount();
		//Log.e("HJJ", "nextpage:" + nextPage + ", page:" + page + ", sum:" + sum + ",itemcount:" + mContent.getItemCount());
		if (0 <= page && page < sum) {
			return true;
		}
		return false;
	}

	@Override
	public boolean onExitScrollArea() {
		// TODO Auto-generated method stub
		boolean result = false;
        if (mInScrollArea) {
            result = true;
            mInScrollArea = false;
        }
        return result;
	}

	@Override
	public void onProcessAfterUnload() {
		// TODO Auto-generated method stub
		mShowAddViewAfterUnload = true;
	}

	@Override
	public void updateShortcutItem(ShortcutInfo item) {
		// TODO Auto-generated method stub
		mContent.updateShortcutItem(item);
	}
	
	public void setFolderDefaultName(){
		Resources res = getResources();
		 sDefaultFolderName = res.getString(R.string.folder_name);
	}
}
